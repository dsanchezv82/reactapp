import { AlertCircle, Calendar, Clock, MapPin, Users } from 'lucide-react-native';
import { useEffect, useState } from 'react';
import {
    Alert,
    FlatList,
    Platform,
    RefreshControl,
    StyleSheet,
    TouchableOpacity,
    View,
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';

// Import themed components following mobile best practices
import ThemedText from '../components/ThemedText';
import ThemedView from '../components/ThemedView';
import { useAuth } from '../contexts/AuthContext';
import { useTheme } from '../contexts/ThemeContext';

// Backend API configuration - secure production domain
const API_BASE_URL = 'https://api.garditech.com/api'; // Match AuthContext configuration

// Event interface matching Surfsight API response
interface Event {
  id: string;
  eventType: string;
  timestamp: string;
  location?: {
    latitude: number;
    longitude: number;
  };
  severity?: 'low' | 'medium' | 'high' | 'critical';
  description?: string;
  videoUrl?: string;
  thumbnailUrl?: string;
  metadata?: Record<string, any>;
}

interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export default function EventsScreen() {
  const [events, setEvents] = useState<Event[]>([]);
  const [refreshing, setRefreshing] = useState(false);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<'all' | 'attending' | 'upcoming'>('all');

  const { theme, isDark } = useTheme();
  const { user, authToken } = useAuth();
  const insets = useSafeAreaInsets();

  useEffect(() => {
    loadEvents();
  }, []);

  // Load events from backend with proper authentication
  const loadEvents = async () => {
    try {
      console.log('ðŸ”„ Loading events from backend...');
      
      const response = await fetch(`${API_BASE_URL}/events`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authToken}`,
        },
      });

      const data: ApiResponse<Event[]> = await response.json();

      if (response.ok && data.success) {
        setEvents(data.data || []);
        console.log('âœ… Events loaded successfully:', data.data?.length || 0);
      } else {
        console.log('âŒ Failed to load events:', data.error);
        Alert.alert('Error', data.error || 'Failed to load events');
        setEvents([]);
      }
    } catch (error) {
      console.log('âŒ Network error loading events:', error);
      Alert.alert(
        'Network Error', 
        'Unable to connect to server. Please check your internet connection and try again.'
      );
      setEvents([]);
    } finally {
      setLoading(false);
    }
  };

  // Pull-to-refresh functionality for mobile UX
  const onRefresh = async () => {
    setRefreshing(true);
    await loadEvents();
    setRefreshing(false);
  };

  // Toggle event attendance with backend sync
  const toggleAttendance = async (eventId: string) => {
    try {
      console.log('ðŸ”„ Toggling attendance for event:', eventId);
      
      const response = await fetch(`${API_BASE_URL}/events/${eventId}/attendance`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authToken}`,
        },
      });

      const data: ApiResponse<{ isAttending: boolean; attendeeCount: number }> = await response.json();

      if (response.ok && data.success) {
        // Update local state with backend response
        setEvents(prev =>
          prev.map(event =>
            event.id === eventId
              ? {
                  ...event,
                  isUserAttending: data.data!.isAttending,
                  attendees: data.data!.attendeeCount
                }
              : event
          )
        );
        console.log('âœ… Attendance updated successfully');
      } else {
        console.log('âŒ Failed to update attendance:', data.error);
        Alert.alert('Error', data.error || 'Failed to update attendance');
      }
    } catch (error) {
      console.log('âŒ Network error updating attendance:', error);
      Alert.alert('Network Error', 'Failed to update attendance. Please try again.');
    }
  };

  // Cross-platform category icons following mobile design guidelines
  const getCategoryIcon = (category: Event['category']) => {
    switch (category) {
      case 'safety':
        return <AlertCircle size={20} color="#FF3B30" strokeWidth={2} />;
      case 'training':
        return <Calendar size={20} color="#007AFF" strokeWidth={2} />;
      case 'community':
        return <Users size={20} color="#34C759" strokeWidth={2} />;
      case 'maintenance':
        return <Calendar size={20} color="#FF9500" strokeWidth={2} />;
      default:
        return <Calendar size={20} color={theme.colors.primary} strokeWidth={2} />;
    }
  };

  // Mobile-optimized time formatting
  const formatEventTime = (startTime: string, endTime: string) => {
    const start = new Date(startTime);
    const end = new Date(endTime);
    const now = new Date();
    
    const isToday = start.toDateString() === now.toDateString();
    const isTomorrow = start.toDateString() === new Date(now.getTime() + 24 * 60 * 60 * 1000).toDateString();
    
    let dateStr = '';
    if (isToday) dateStr = 'Today';
    else if (isTomorrow) dateStr = 'Tomorrow';
    else dateStr = start.toLocaleDateString();
    
    const timeStr = `${start.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })} - ${end.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
    
    return `${dateStr} â€¢ ${timeStr}`;
  };

  // Client-side filtering for optimal mobile performance
  const getFilteredEvents = () => {
    const now = new Date();
    switch (filter) {
      case 'attending':
        return events.filter(event => event.isUserAttending);
      case 'upcoming':
        return events.filter(event => new Date(event.startTime) > now);
      default:
        return events.sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime());
    }
  };

  // Cross-platform event card component
  const renderEvent = ({ item }: { item: Event }) => (
    <TouchableOpacity
      style={[
        styles.eventItem,
        {
          backgroundColor: theme.colors.surface,
          borderColor: theme.colors.border,
        }
      ]}
      activeOpacity={0.7}
    >
      <View style={styles.eventContent}>
        <View style={styles.eventHeader}>
          {getCategoryIcon(item.category)}
          <View style={styles.eventInfo}>
            <ThemedText type="subtitle" style={styles.eventTitle}>
              {item.title}
            </ThemedText>
            <View style={styles.eventMeta}>
              <Clock size={14} color={theme.colors.textSecondary} strokeWidth={2} />
              <ThemedText type="secondary" style={styles.eventTime}>
                {formatEventTime(item.startTime, item.endTime)}
              </ThemedText>
            </View>
          </View>
          {item.isUserAttending && (
            <View style={[styles.attendingBadge, { backgroundColor: theme.colors.primary }]}>
              <ThemedText style={styles.attendingText}>Going</ThemedText>
            </View>
          )}
        </View>
        
        <ThemedText style={styles.eventDescription}>
          {item.description}
        </ThemedText>

        <View style={styles.eventDetails}>
          <View style={styles.eventLocation}>
            <MapPin size={14} color={theme.colors.textSecondary} strokeWidth={2} />
            <ThemedText type="secondary" style={styles.locationText}>
              {item.location}
            </ThemedText>
          </View>
          
          <View style={styles.eventAttendees}>
            <Users size={14} color={theme.colors.textSecondary} strokeWidth={2} />
            <ThemedText type="secondary" style={styles.attendeesText}>
              {item.attendees}{item.maxAttendees ? `/${item.maxAttendees}` : ''} attending
            </ThemedText>
          </View>
        </View>

        <TouchableOpacity
          style={[
            styles.attendButton,
            item.isUserAttending 
              ? { backgroundColor: theme.colors.surface, borderColor: theme.colors.primary, borderWidth: 1 }
              : { backgroundColor: theme.colors.primary }
          ]}
          onPress={() => toggleAttendance(item.id)}
          activeOpacity={0.7}
        >
          <ThemedText style={[
            styles.attendButtonText,
            { color: item.isUserAttending ? theme.colors.primary : '#FFFFFF' }
          ]}>
            {item.isUserAttending ? 'Cancel' : 'Attend'}
          </ThemedText>
        </TouchableOpacity>
      </View>
    </TouchableOpacity>
  );

  // Filter button component for clean UI
  const FilterButton = ({ title, filterValue }: { title: string; filterValue: typeof filter }) => (
    <TouchableOpacity
      style={[
        styles.filterButton,
        filter === filterValue && { backgroundColor: theme.colors.primary },
        { borderColor: theme.colors.primary }
      ]}
      onPress={() => setFilter(filterValue)}
      activeOpacity={0.7}
    >
      <ThemedText style={[
        styles.filterButtonText,
        { color: filter === filterValue ? '#FFFFFF' : theme.colors.primary }
      ]}>
        {title}
      </ThemedText>
    </TouchableOpacity>
  );

  const dynamicStyles = StyleSheet.create({
    container: {
      flex: 1,
      backgroundColor: theme.colors.background,
      paddingTop: insets.top,
    },
    header: {
      flexDirection: 'row',
      justifyContent: 'space-between',
      alignItems: 'center',
      paddingHorizontal: 20,
      paddingVertical: 16,
      backgroundColor: theme.colors.surface,
      borderBottomWidth: StyleSheet.hairlineWidth,
      borderBottomColor: theme.colors.border,
    },
    emptyContainer: {
      flex: 1,
      justifyContent: 'center',
      alignItems: 'center',
      paddingHorizontal: 32,
    },
  });

  const filteredEvents = getFilteredEvents();

  // Loading state with proper mobile UX
  if (loading) {
    return (
      <ThemedView style={dynamicStyles.container}>
        <View style={dynamicStyles.header}>
          <ThemedText type="title">Events</ThemedText>
        </View>
        <View style={dynamicStyles.emptyContainer}>
          <Calendar size={48} color={theme.colors.textSecondary} strokeWidth={1.5} />
          <ThemedText type="secondary" style={{ marginTop: 16 }}>
            Loading events...
          </ThemedText>
        </View>
      </ThemedView>
    );
  }

  return (
    <ThemedView style={dynamicStyles.container}>
      {/* Header */}
      <View style={dynamicStyles.header}>
        <ThemedText type="title">Events</ThemedText>
      </View>

      {/* Filter buttons for enhanced mobile UX */}
      <View style={styles.filterContainer}>
        <FilterButton title="All" filterValue="all" />
        <FilterButton title="Attending" filterValue="attending" />
        <FilterButton title="Upcoming" filterValue="upcoming" />
      </View>

      {filteredEvents.length === 0 ? (
        <View style={dynamicStyles.emptyContainer}>
          <Calendar size={48} color={theme.colors.textSecondary} strokeWidth={1.5} />
          <ThemedText type="title" style={styles.emptyTitle}>
            No Events Found
          </ThemedText>
          <ThemedText type="secondary" style={styles.emptySubtitle}>
            {filter === 'all' 
              ? "No events scheduled at the moment."
              : filter === 'attending'
              ? "You're not attending any events yet."
              : "No upcoming events found."
            }
          </ThemedText>
        </View>
      ) : (
        <FlatList
          data={filteredEvents}
          renderItem={renderEvent}
          keyExtractor={(item) => item.id}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={onRefresh}
              tintColor={theme.colors.primary}
              colors={[theme.colors.primary]}
            />
          }
          showsVerticalScrollIndicator={false}
          contentContainerStyle={styles.listContainer}
          // Mobile performance optimization
          removeClippedSubviews={Platform.OS === 'android'}
          maxToRenderPerBatch={10}
          windowSize={10}
        />
      )}
    </ThemedView>
  );
}

// Cross-platform styles following mobile design guidelines
const styles = StyleSheet.create({
  listContainer: {
    paddingVertical: 8,
  },
  filterContainer: {
    flexDirection: 'row',
    paddingHorizontal: 20,
    paddingVertical: 16,
    gap: 12,
  },
  filterButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    borderWidth: 1,
  },
  filterButtonText: {
    fontSize: 14,
    fontWeight: '500',
  },
  eventItem: {
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 12,
    borderWidth: StyleSheet.hairlineWidth,
    ...Platform.select({
      ios: {
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4,
      },
      android: {
        elevation: 2,
      },
    }),
  },
  eventContent: {
    padding: 16,
  },
  eventHeader: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 12,
  },
  eventInfo: {
    flex: 1,
    marginLeft: 12,
  },
  eventTitle: {
    marginBottom: 4,
  },
  eventMeta: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  eventTime: {
    fontSize: 12,
    marginLeft: 4,
  },
  attendingBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  attendingText: {
    color: '#FFFFFF',
    fontSize: 12,
    fontWeight: '500',
  },
  eventDescription: {
    marginBottom: 16,
    lineHeight: 20,
  },
  eventDetails: {
    marginBottom: 16,
  },
  eventLocation: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  locationText: {
    fontSize: 14,
    marginLeft: 6,
  },
  eventAttendees: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  attendeesText: {
    fontSize: 14,
    marginLeft: 6,
  },
  attendButton: {
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    alignItems: 'center',
  },
  attendButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
  emptyTitle: {
    marginTop: 16,
    marginBottom: 8,
    textAlign: 'center',
  },
  emptySubtitle: {
    textAlign: 'center',
    lineHeight: 20,
  },
});